defmodule Aecore.Structures.ChannelOpenTx do
  @moduledoc """
  Aecore structure of a transaction data.
  """

  @behaviour Aecore.Structures.Transaction
  alias Aecore.Structures.ChannelOpenTx
  alias Aecore.Structures.Account
  alias Aecore.Chain.ChainState
  alias Aecore.Wallet
  alias Aecore.Structures.Account

  require Logger

  @typedoc "Expected structure for the ChannelOpen Transaction"
  @type payload :: %{
    initiator_amount: non_neg_integer(),
    responser_amount: non_neg_integer(),
    locktime: non_neg_integer()
  }

  @typedoc "Reason for the error"
  @type reason :: String.t()

  @typedoc "Structure that holds specific transaction info in the chainstate.
  In the case of SpendTx we don't have a subdomain chainstate."
  @type tx_type_state() :: %{}

  @typedoc "Structure of the ChannelOpen Transaction type"
  @type t :: %ChannelOpenTx{
    initiator_amount: non_neg_integer(),
    responser_amount: non_neg_integer(),
    locktime: non_neg_integer()
  }

  @doc """
  Definition of Aecore ChannelOpenTx structure

  ## Parameters
  - initiator_amount: amount that account second on the from_accs list commits
  - responser_amount: amount that account first on the from_accs list commits
  - locktime: number of blocks before solo close is settled
  """
  defstruct [:initiator_amount, :responder_amount, :locktime]
  use ExConstructor

  # Callbacks

  @spec init(payload()) :: SpendTx.t()
  def init(%{initiator_amount: initiator_amount, responder_amount: responder_amount, locktime: locktime} = _payload) do
    %ChannelOpenTx{initiator_amount: initiator_amount, responder_amount: responder_amount, locktime: locktime}
  end

  @doc """
  Checks transactions internal contents validity
  """
  @spec is_valid?(ChannelOpenTx.t(), list(binary), integer()) :: boolean()
  def is_valid?(%ChannelOpenTx{} = tx, from_accs, fee) do
   cond do
      tx.initiator_amount + tx.responder_amount < 0 ->
        Logger.error("Channel cannot have negative total balance")
        false

      tx.locktime < 0 ->
        Logger.error("Locktime cannot be negative")
        false

      fee <= 0 ->
        Logger.error("Fee has to be > 0")
        false

      length(from_accs) != 2 ->
        Logger.error("Invalid from_accs size")
        false

      true ->
        true
    end
  end

  @doc """
  Changes the account state (balance) of both parties and creates channel object
  """
  @spec process_chainstate!(
          ChainState.chainstate(),
          SpendTx.t(),
          list(binary()),
          non_neg_integer()
        ) :: {ChainState.accounts(), tx_type_state()}
  def process_chainstate!(chainstate, %ChannelOpenTx{} = tx, [responder_acc, initiator_acc], _fee) do
    new_accounts =
      chainstate.accounts
      |> MapUtil.update(initiator_acc, Account.empty(), fn acc ->
        Account.transaction_in!(tx.initiator_amount * -1)
      end)
      |> MapUtil.update(responder_acc, Account.empty(), fn acc ->
        Account.transaction_in!(tx.responder_amount * -1)
      end)

    new_channels = Map.put(
      chainstate.channels,

    %{chainstate | accounts: new_accounts}
  end

  @doc """
  Checks whether all the data is valid according to the SpendTx requirements,
  before the transaction is executed.
  """
  @spec preprocess_check(
          SpendTx.t(),
          ChainState.account(),
          list(binary()),
          non_neg_integer()
        ) :: :ok | {:error, String.t()}
  def preprocess_check(tx, chainstate, [responder_acc, initiator_acc], fee) do
    case do
      chainstate.accounts[initiator_acc].balance - (fee + tx.initiator_amount) < 0 ->
        {:error, "Negative initiator balance"}
      chainstate.accounts[responder_acc].balance - (tx.responder_amount) < 0 ->
        {:error, "Negative responder balance"}
      true ->
        :ok
    end
  end

  @spec deduct_fee(ChainState.chainstate(), SpendTx.t(), list(binary()), non_neg_integer()) ::
          ChainState.account()
  def deduct_fee(chainstate, _tx, [from_acc], fee) do
    new_accounts =
      MapUtil.update!(chainstate.accounts, from_acc, fn acc ->
        Account.transaction_in(acc, fee * -1)
      end)

    %{chainstate | accounts: new_accounts}
  end
end
